# Qiling

Qiling is an advanced binary emulation framework written in python and based on Unicorn engine.

It supports multiple platform (Windows, MacOS, Linux, BSD, UEFI) and multiple architectures (X86, X86_64, Arm, Arm64, MIPS).

Qiling is designed as a higher level framework, that leverages Unicorn to emulate CPU instructions, but Qiling understands OS as it has executable format loaders (for PE, MachO & ELF at the moment), dynamic linkers (so we can load & relocate shared libraries), syscall & IO handlers. For this reason, Qiling can run executable binaries that normally runs in native OS.

Pre-install prep:

```bash
sudo apt install -y ack antlr3 aria2 asciidoc autoconf automake autopoint binutils bison build-essential \
bzip2 ccache cmake cpio curl device-tree-compiler fastjar flex gawk gettext gcc-multilib g++-multilib \
git gperf haveged help2man intltool libc6-dev-i386 libelf-dev libglib2.0-dev libgmp3-dev libltdl-dev \
libmpc-dev libmpfr-dev libncurses5-dev libncursesw5-dev libreadline-dev libssl-dev libtool lrzsz \
mkisofs msmtp nano ninja-build p7zip p7zip-full patch pkgconf python2.7 python3 python3-pip libpython3-dev qemu-utils \
rsync scons squashfs-tools subversion swig texinfo uglifyjs upx-ucl unzip vim wget xmlto xxd zlib1g-dev
```

Install via pip:

```bash
pip install qiling
```

if encountering any error then plz create an python virtual env and then do it again

or you could do it manually by going in the source code directory and executing this command

```bash
pip install .
```

so this will then install and create an new file called qltool though which you can start emulation

# Emulating a File

- ## For x8664 linux

here we will just emulate an linux elf file

```bash
‚îå‚îÄ‚îÄ(qiling_venv)(kali„âøDESKTOP-GDG9QEA)-[~/qiling]
‚îî‚îÄ$ ./qltool
usage: qltool [-h] [--version] {run,code,examples,qltui} ...
qltool: error: the following arguments are required: subcommand
```

we can use exmples to see how it works

in Qiling, the executable you want to emulate must be placed inside the rootfs, just like it would exist on a real filesystem for that OS.

Directory Structure (Example for Linux x86_64):

If you're emulating a Linux x86_64 binary, the folder structure should look like

```bash
qiling/
‚îî‚îÄ‚îÄ examples/
    ‚îú‚îÄ‚îÄ hello_x8664_linux.py
    ‚îî‚îÄ‚îÄ rootfs/
        ‚îî‚îÄ‚îÄ x8664_linux/
            ‚îú‚îÄ‚îÄ bin/
            ‚îÇ   ‚îî‚îÄ‚îÄ x8664_hello       ‚Üê üü¢ Your target binary here
            ‚îú‚îÄ‚îÄ lib/
            ‚îú‚îÄ‚îÄ lib64/
            ‚îî‚îÄ‚îÄ ...
```

then run this python script

```bash
from qiling import Qiling
from qiling.const import QL_VERBOSE

# Make sure the path matches the ELF binary's location
ql = Qiling(["rootfs/x8664_linux/bin/test"], "rootfs/x8664_linux", verbose=QL_VERBOSE.DEFAULT)
ql.run()

```

but this will give you an error that rootfs/x8664_linux/bin/test: /lib/libc.so.6: version `GLIBC_2.34' not found (required by rootfs/x8664_linux/bin/test)

so to see what version your executable support you need to do this

```bash
strings ./your_binary | grep GLIBC_
```

here you can see that

```bash
GLIBC_2.2.5
GLIBC_2.34
__libc_start_main@GLIBC_2.34
puts@GLIBC_2.2.5
__cxa_finalize@GLIBC_2.2.5
```

this shows that

- Your executable depends on GLIBC 2.34 features or newer.
- You must run it with a matching or newer libc (and loader) to avoid "GLIBC version not found" errors.

so in rootfs directory you can see

```bash
‚îå‚îÄ‚îÄ(qiling_venv)(kali„âøDESKTOP-GDG9QEA)-[~/qiling/examples/rootfs]
‚îî‚îÄ$ ls
8086              arm64_linux    blob            powerpc_linux  x8664_efi              x8664_macos
arm64_android     armeb_linux    evm             README.md      x8664_freebsd          x8664_windows
arm64_android6.0  arm_linux      mcu             riscv32_linux  x8664_linux            x86_linux
arm64_edl         arm_qnx        mips32el_linux  riscv64_linux  x8664_linux_glibc2.39  x86_linux_glibc2.39
arm64_ios         arm_tendaac15  mips32_linux    test           x8664_linux_symlink    x86_windows
```

now wee will use `x8664_linux_glibc2.39` which is supported by the executable

update this

```bash
ql = Qiling(["rootfs/x8664_linux/bin/test"], "rootfs/x8664_linux_glibc2.39", verbose=QL_VERBOSE.DEFAULT)
```

output

```bash
‚îå‚îÄ‚îÄ(qiling_venv)(kali„âøDESKTOP-GDG9QEA)-[~/qiling/examples]
‚îî‚îÄ$ python3 test.py
[=]     brk(inp = 0x0) = 0x55555555b000
[=]     access(path = 0x7ffff7e045b0, mode = 0x4) = -0x2 (ENOENT)
[=]     openat(fd = 0xffffff9c, path = 0x7ffff7e0338f, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)
[=]     openat(fd = 0xffffff9c, path = 0x7fffffffee40, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)
[=]     newfstatat(dirfd = 0xffffff9c, path = 0x7fffffffee40, buf = 0x7fffffffef00, flags = 0x0) = -0x2 (ENOENT)
[=]     openat(fd = 0xffffff9c, path = 0x7fffffffee40, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)
[=]     newfstatat(dirfd = 0xffffff9c, path = 0x7fffffffee40, buf = 0x7fffffffef00, flags = 0x0) = -0x2 (ENOENT)
[=]     openat(fd = 0xffffff9c, path = 0x7fffffffee40, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)
[=]     newfstatat(dirfd = 0xffffff9c, path = 0x7fffffffee40, buf = 0x7fffffffef00, flags = 0x0) = -0x2 (ENOENT)
[=]     openat(fd = 0xffffff9c, path = 0x7fffffffee40, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)
[=]     newfstatat(dirfd = 0xffffff9c, path = 0x7fffffffee40, buf = 0x7fffffffef00, flags = 0x0) = -0x2 (ENOENT)
[=]     openat(fd = 0xffffff9c, path = 0x7fffffffee40, flags = 0x80000, mode = 0x0) = -0x2 (ENOENT)
[=]     newfstatat(dirfd = 0xffffff9c, path = 0x7fffffffee40, buf = 0x7fffffffef00, flags = 0x0) = -0x2 (ENOENT)
[=]     openat(fd = 0xffffff9c, path = 0x7fffffffee40, flags = 0x80000, mode = 0x0) = 0x3
[=]     read(fd = 0x3, buf = 0x7ffffffff068, length = 0x340) = 0x340
[=]     pread64(fd = 0x3, buf = 0x7fffffffead0, length = 0x310, offt = 0x40) = 0x310
[=]     fstat(fd = 0x3, buf = 0x7fffffffef00) = 0x0
[=]     pread64(fd = 0x3, buf = 0x7fffffffeb50, length = 0x310, offt = 0x40) = 0x310
[=]     mmap(addr = 0x0, length = 0x211d90, prot = 0x1, flags = 0x802, fd = 0x3, pgoffset = 0x0) = 0x7fffb7dd6000
[=]     mmap(addr = 0x7fffb7dfe000, length = 0x188000, prot = 0x5, flags = 0x812, fd = 0x3, pgoffset = 0x28000) = 0x7fffb7dfe000
[=]     mmap(addr = 0x7fffb7f86000, length = 0x4f000, prot = 0x1, flags = 0x812, fd = 0x3, pgoffset = 0x1b0000) = 0x7fffb7f86000
[=]     mmap(addr = 0x7fffb7fd5000, length = 0x6000, prot = 0x3, flags = 0x812, fd = 0x3, pgoffset = 0x1fe000) = 0x7fffb7fd5000
[=]     mmap(addr = 0x7fffb7fdb000, length = 0xcd90, prot = 0x3, flags = 0x32, fd = 0xffffffff, pgoffset = 0x0) = 0x7fffb7fdb000
[=]     close(fd = 0x3) = 0x0
[=]     mmap(addr = 0x0, length = 0x2000, prot = 0x3, flags = 0x22, fd = 0xffffffff, pgoffset = 0x0) = 0x7fffb7fe8000
[=]     arch_prctl(code = 0x1002, addr = 0x7fffb7fe90c0) = 0x0
[=]     set_tid_address(tidptr = 0x7fffb7fe9390) = 0x1d88
[=]     set_robust_list(head_ptr = 0x7fffb7fe93a0, head_len = 0x18) = 0x0
[!]     0x7ffff7de9ff4: syscall ql_syscall_rseq number = 0x14e(334) not implemented
[=]     mprotect(start = 0x7fffb7fd5000, mlen = 0x4000, prot = 0x1) = 0x0
[=]     mprotect(start = 0x555555557000, mlen = 0x1000, prot = 0x1) = 0x0
[=]     mprotect(start = 0x7ffff7e0b000, mlen = 0x2000, prot = 0x1) = 0x0
[=]     prlimit64(pid = 0x0, res = 0x3, new_limit = 0x0, old_limit = 0x7ffffffffa50) = 0x0
[=]     fstat(fd = 0x1, buf = 0x7ffffffffb60) = 0x0
[=]     getrandom(buf = 0x7fffb7fe0178, buflen = 0x8, flags = 0x1) = 0x8
[=]     brk(inp = 0x0) = 0x55555555b000
[=]     brk(inp = 0x55555557c000) = 0x55555557c000
Hello, World!     # heres the output
[=]     write(fd = 0x1, buf = 0x55555555b2a0, count = 0xe) = 0xe
[=]     exit_group(code = 0x0) = ?
```

---

<br><br>

- ## For windows

now lets do this for windows we it is quite different from the linux

> [NOTE:]
> Important note on Windows DLLs and registry
>
> Due to distribution restriction, Qiling Framework will not bundle Microsoft Windows DLL files and registry. Please copy respective DLLs and registry from Microsoft Windows System. For Windows 10 usually found in C:\Windows\system32 (64bit dll) and C:\Windows\SysWOW64 (32bits dll) and place them in $rootfs/dlls
>
> `dllscollector.bat`. Run this on Windows, under Administrator privilege, to collect all the necessary dlls and registries.

this will create an example folder in the system32 you need to copy that an paste in your linux system

copy the contents of the folder in the rootsfs folder of linux

and then we are ready to go

heres the script

```bash
from qiling import Qiling
from qiling.const import QL_VERBOSE

# Correct path to binary and rootfs
ql = Qiling(["rootfs/x8664_windows/bin/hello.exe"], "rootfs/x8664_windows", verbose=QL_VERBOSE.DEFAULT)
ql.run()
```

```bash
.
.
.
.
[=]     GetSystemTimeAsFileTime(lpSystemTimeAsFileTime = 0x80000001cf50)
[=]     _initterm(pfbegin = 0x110177478, pfend = 0x110177488) = 0x0
[=]     Returned from msvcrt.dll DllMain
[=]     Done loading msvcrt.dll
[=]     __set_app_type(at = 0x1)
[=]     _initterm(pfbegin = 0x140009000, pfend = 0x140009010) = 0x0
[=]     SetUnhandledExceptionFilter(lpTopLevelExceptionFilter = 0x140001cf0) = 0x0
[=]     malloc(size = 0x8) = 0x5000097e8
[=]     atexit(func = 0x140001450) = 0x0
[=]     atexit(func = 0x140001490) = 0x0
Hello, World!
[=]     puts(str = "Hello, World!") = 0xe
[=]     exit(status = 0)
```


here you can see we have succesfully emulated windows binary in the linux uisng qiling 
